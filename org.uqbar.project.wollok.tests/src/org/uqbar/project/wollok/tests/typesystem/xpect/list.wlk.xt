/* XPECT_SETUP org.uqbar.project.wollok.tests.typesystem.xpect.TypeSystemXpectTestCase END_SETUP */

/** 
 * Tests generales a todas las collecciones
 *
 * Si bien los tests en esta clase son comunes a todas las colecciones, Wollok no podría tiparlo genericamente.
 * Para testear tanto lists como sets, esta clase está duplicada, salvo por la declaración de `sample`. 
 */	
class TestCollection {
	const sample = [1, 2, 3]

	method generalCollection() {
		// XPECT type at asList --> List
		const asList = sample.asList()
		
		// XPECT type at asSet --> Set
		const asSet = sample.asSet()
		
		// XPECT type at isEmpty --> Boolean
		const isEmpty = sample.isEmpty()
		
		// XPECT type at contains --> {(Number) => Boolean}
		const contains = { e => sample.contains(e) }
	
		// XPECT type at occurrencesOf --> {(Number) => Number}
		const occurrencesOf = { e => sample.occurrencesOf(e) }
	}

	method basicClosures() {
		// XPECT type at filterSome --> Number
		const filterSome = sample.filter { x => x.even }.first() 		

		// XPECT type at findSome --> Number
		const findSome = sample.find { x => x.even }

		// XPECT type at forEach --> {({Number => Void}) => Void}
		const forEach = { closure => sample.forEach(closure) }
		
	}
	
	// Requieren comparable	
	// method max(closure)
	//	method max()		
	//	method min(closure)
	//	method min() = self.min({it => it})
//		method sortedBy(closure)

	//	Requieren sumables
	//	method sum(closure) = self.fold(0, { acc, e => acc + closure.apply(e) })
	//	method sum() = self.sum( {it => it} )

	// Requiere method-scoped type parameters	
	//	method map(closure) = self.fold([], { acc, e =>
	//	method flatMap(closure) = self.fold(self.newInstance(), { acc, e =>
}

/**
 * Tests de métodos específicos de listas, 
 * o bien aquellos que devuelven un tipo distinto dependiendo del receptor (e.g. filter)
 */
class TestList {
	const sample = [1, 2, 3]

	method listSpecific() {
		// XPECT type at first --> Number
		const first = sample.first() 	
	}


	// Métodos generales de collection pero que Requieren self type
	//	 method filter(closure) = self.fold(self.newInstance(), { acc, e =>
	//	method +(elements) {
	//	method addAll(elements) { elements.forEach { e => self.add(e) } }
	//	method removeAll(elements) { 
	//	 method removeAllSuchThat(closure) {
	//	method flatten() = self.flatMap { e => e }
	//	method copy() {
	//	method newInstance()	
}